<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENTROPY PROTOCOL - Tactical Update</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');

        :root {
            --bg-color: #1a1b1e;
            --ui-bg: rgba(30, 34, 40, 0.95);
            --ui-border: #4a4f5a;
            --accent: #ffaa00; /* Tactical Amber */
            --danger: #e63946;
            --text-main: #e0e6ed;
            --text-dim: #94a3b8;
        }

        body {
            margin: 0; overflow: hidden; background-color: var(--bg-color);
            font-family: 'Roboto Mono', monospace; color: var(--text-main); user-select: none;
        }

        canvas { display: block; }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD ELEMENTS */
        .hud-panel {
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            padding: 10px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: auto;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        
        .stat-label { font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 4px; }
        .stat-value { font-size: 1.5rem; font-weight: 700; color: var(--text-main); }

        /* ENTROPY METER (Tactical Style) */
        .entropy-wrapper {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 400px;
            background: var(--ui-bg); border: 1px solid var(--ui-border);
            padding: 10px; border-radius: 4px;
        }

        .bar-container {
            width: 100%; height: 16px; background: #0f1115;
            border: 1px solid #333; position: relative;
        }

        .bar-fill {
            height: 100%; width: 0%;
            background: repeating-linear-gradient(
                -45deg,
                var(--accent),
                var(--accent) 5px,
                #cc8800 5px,
                #cc8800 10px
            );
            transition: width 0.2s;
        }
        
        .bar-fill.critical { background: var(--danger); }

        /* MAIN MENU */
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 17, 21, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; backdrop-filter: blur(5px);
        }

        h1 { font-size: 3rem; margin-bottom: 10px; color: var(--accent); letter-spacing: -2px; }
        .subtitle { color: var(--text-dim); margin-bottom: 40px; font-size: 1rem; }

        .btn-main {
            background: var(--accent); color: #1a1b1e; border: none;
            padding: 15px 40px; font-size: 1.2rem; font-weight: 700; font-family: inherit;
            cursor: pointer; clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
            transition: transform 0.1s, background 0.1s;
        }
        .btn-main:hover { transform: scale(1.05); background: white; }
        .btn-main:active { transform: scale(0.95); }

        /* UPGRADE CARDS */
        #upgrade-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        
        .cards-container { display: flex; gap: 20px; margin-top: 30px; }
        
        .card {
            background: var(--ui-bg); border: 1px solid var(--ui-border);
            width: 220px; padding: 20px; cursor: pointer; text-align: left;
            transition: 0.2s; position: relative;
        }
        .card:hover { border-color: var(--accent); transform: translateY(-5px); }
        .card h3 { color: var(--accent); font-size: 1rem; margin: 0 0 10px 0; }
        .card p { font-size: 0.8rem; color: var(--text-dim); line-height: 1.4; margin: 0; }
        
        /* Rarity Borders */
        .card.common { border-top: 4px solid #a8a8a8; }
        .card.rare { border-top: 4px solid #00f3ff; }
        .card.epic { border-top: 4px solid #bd00ff; }
        .card.legendary { border-top: 4px solid #ffaa00; }

        /* GAME OVER */
        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 0, 0, 0.9); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="display:none;">
        <div class="hud-top">
            <div class="hud-panel">
                <span class="stat-label">Mission Time</span>
                <span class="stat-value" id="score-display">00:00</span>
            </div>
            
            <div class="entropy-wrapper" id="entropy-hud">
                <div style="display: flex; justify-content: space-between; margin-bottom:5px;">
                    <span class="stat-label">System Integrity</span>
                    <span class="stat-label" id="entropy-val" style="color:var(--text-main);">100%</span>
                </div>
                <div class="bar-container">
                    <div class="bar-fill" id="entropy-bar"></div>
                </div>
            </div>

            <div class="hud-panel" style="text-align: right;">
                <span class="stat-label">Clearance Level</span>
                <span class="stat-value" id="level-display">1</span>
            </div>
        </div>
    </div>

    <div id="main-menu">
        <h1>ENTROPY PROTOCOL</h1>
        <div class="subtitle">TACTICAL SURVIVAL // DECAY INEVITABLE</div>
        <button class="btn-main" onclick="startGame()">INITIATE DEPLOYMENT</button>
    </div>

    <div id="upgrade-screen">
        <h2 style="color:white; letter-spacing: 2px;">SYSTEM INTERRUPT</h2>
        <div class="cards-container" id="cards-container"></div>
    </div>

    <div id="game-over">
        <h1 style="color: var(--danger);">MIA / KIA</h1>
        <p id="final-stats" style="color: #aaa; margin-bottom:30px;">DURATION: 0s</p>
        <button class="btn-main" onclick="location.reload()">REDEPLOY</button>
    </div>

<script>
// --- CONFIGURATION ---
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

// --- GAME STATE ---
const Game = {
    state: 'MENU', // MENU, RUNNING, PAUSED, OVER
    width: window.innerWidth,
    height: window.innerHeight,
    
    // WORLD SIZE (The map is bigger than the screen)
    worldWidth: 3000,
    worldHeight: 3000,
    
    frames: 0,
    score: 0,
    entropy: 0, 
    entropyRate: 0.03,
    freezeTimer: 0,

    player: null,
    enemies: [],
    particles: [],
    gems: [],
    projectiles: [],
    damageNumbers: [],
    
    camera: { x: 0, y: 0 },
    
    shake: 0,
};

// --- INPUT ---
const Input = { 
    keys: {},
    mouse: { x: 0, y: 0, worldX: 0, worldY: 0 } 
};

window.addEventListener('keydown', e => Input.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => Input.keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => {
    Input.mouse.x = e.clientX;
    Input.mouse.y = e.clientY;
});
window.addEventListener('resize', () => {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
    Game.width = CANVAS.width;
    Game.height = CANVAS.height;
});
CANVAS.width = window.innerWidth;
CANVAS.height = window.innerHeight;

// --- UTILS ---
const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
const rand = (min, max) => Math.random() * (max - min) + min;

// --- CLASSES ---

class Player {
    constructor() {
        this.x = Game.worldWidth / 2;
        this.y = Game.worldHeight / 2;
        this.baseSize = 25;
        this.baseSpeed = 6;
        this.level = 1;
        this.nextLevel = 10;
        this.xp = 0;
        
        this.weapons = {
            blaster: { cd: 0, maxCd: 12, damage: 30 },
            orbital: { angle: 0, count: 3, radius: 120, damage: 20 },
            nova: { cd: 0, maxCd: 200, damage: 60 } 
        };

        this.decayResist = 1.0; 
    }

    update() {
        const integrity = Math.max(0, 1 - (Game.entropy / 100));
        const currentSpeed = this.baseSpeed * (0.2 + (0.8 * integrity)); 
        const size = this.baseSize * (0.6 + (0.4 * integrity)); // Shrinks less drastically

        // Movement
        let dx = 0; let dy = 0;
        if (Input.keys['w'] || Input.keys['arrowup']) dy = -1;
        if (Input.keys['s'] || Input.keys['arrowdown']) dy = 1;
        if (Input.keys['a'] || Input.keys['arrowleft']) dx = -1;
        if (Input.keys['d'] || Input.keys['arrowright']) dx = 1;

        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            this.x += (dx / len) * currentSpeed;
            this.y += (dy / len) * currentSpeed;
        }

        // Clamp to WORLD bounds
        this.x = Math.max(size, Math.min(Game.worldWidth - size, this.x));
        this.y = Math.max(size, Math.min(Game.worldHeight - size, this.y));

        // Weapons
        // 1. Blaster
        if (this.weapons.blaster.cd <= 0) {
            let closest = null, minDist = 800; // Search range
            Game.enemies.forEach(e => {
                const d = dist(this.x, this.y, e.x, e.y);
                if (d < minDist) { minDist = d; closest = e; }
            });

            if (closest) {
                const fireDelay = this.weapons.blaster.maxCd * (1 + (2 * (1 - integrity))); 
                this.weapons.blaster.cd = fireDelay;
                const spread = (1 - integrity) * 0.4; 
                const angle = Math.atan2(closest.y - this.y, closest.x - this.x) + rand(-spread, spread);
                const dmg = Math.max(5, this.weapons.blaster.damage * integrity);
                Game.projectiles.push(new Projectile(this.x, this.y, angle, dmg, integrity));
                if (integrity > 0.5) Game.shake += 2;
            }
        } else {
            this.weapons.blaster.cd--;
        }

        // 2. Orbitals
        this.weapons.orbital.angle += 0.04 * (0.5 + 0.5 * integrity); 
        
        // 3. Nova
        if (this.weapons.nova.cd <= 0) {
             const range = 250 * integrity; 
             createNova(this.x, this.y, range, this.weapons.nova.damage * integrity);
             this.weapons.nova.cd = this.weapons.nova.maxCd;
        } else {
            this.weapons.nova.cd--;
        }

        // Entropy
        if(Game.freezeTimer <= 0) {
            Game.entropy += Game.entropyRate * this.decayResist;
            if (Game.entropy > 100) Game.entropy = 100;
        }
    }

    draw() {
        const integrity = Math.max(0, 1 - (Game.entropy / 100));
        const size = this.baseSize * (0.6 + (0.4 * integrity));

        CTX.save();
        CTX.translate(this.x, this.y);

        // Draw Player Body (Tactical Shape)
        CTX.fillStyle = '#4a9eff'; // Steel Blue
        CTX.strokeStyle = '#1e2228';
        CTX.lineWidth = 3;
        
        CTX.beginPath();
        CTX.arc(0, 0, size, 0, Math.PI * 2);
        CTX.fill();
        CTX.stroke();

        // Directional indicator (Turret)
        // Point towards mouse or movement
        let angle = 0;
        if (Input.mouse.x !== 0) {
            // Need to account for camera
            const wx = Input.mouse.x + Game.camera.x;
            const wy = Input.mouse.y + Game.camera.y;
            angle = Math.atan2(wy - this.y, wx - this.x);
        }
        
        CTX.rotate(angle);
        CTX.fillStyle = '#ccc';
        CTX.fillRect(0, -4, size + 8, 8); // Gun barrel
        
        // Center cap
        CTX.beginPath();
        CTX.arc(0,0, size*0.4, 0, Math.PI*2);
        CTX.fillStyle = '#1e2228';
        CTX.fill();

        CTX.restore();
        
        // Draw Orbitals (Drones)
        const orbitRadius = this.weapons.orbital.radius * (0.5 + 0.5 * integrity);
        for(let i=0; i<this.weapons.orbital.count; i++) {
            const theta = this.weapons.orbital.angle + (Math.PI * 2 / this.weapons.orbital.count) * i;
            const ox = this.x + Math.cos(theta) * orbitRadius;
            const oy = this.y + Math.sin(theta) * orbitRadius;
            
            CTX.save();
            CTX.translate(ox, oy);
            CTX.rotate(theta + Game.frames * 0.1);
            CTX.fillStyle = '#ffaa00';
            CTX.fillRect(-6 * integrity, -6 * integrity, 12 * integrity, 12 * integrity); // Square Drones
            CTX.restore();
        }
    }
}

class Projectile {
    constructor(x, y, angle, damage, integrity) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (14 * integrity + 4);
        this.vy = Math.sin(angle) * (14 * integrity + 4);
        this.damage = damage;
        this.life = 50;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw() {
        CTX.fillStyle = '#fff';
        CTX.beginPath();
        CTX.arc(this.x, this.y, 4, 0, Math.PI*2);
        CTX.fill();
    }
}

class Enemy {
    constructor() {
        // Spawn randomly around the player (offscreen but nearby)
        const angle = Math.random() * Math.PI * 2;
        const distFromPlayer = rand(600, 1000); // Outside screen
        this.x = Game.player.x + Math.cos(angle) * distFromPlayer;
        this.y = Game.player.y + Math.sin(angle) * distFromPlayer;

        // Clamp to world
        this.x = Math.max(50, Math.min(Game.worldWidth - 50, this.x));
        this.y = Math.max(50, Math.min(Game.worldHeight - 50, this.y));
        
        const timeFactor = 1 + (Game.score / 5000); 
        this.hp = 25 * timeFactor;
        this.maxHp = this.hp;
        this.speed = rand(2, 3.5) + (timeFactor * 0.1);
        this.size = 18;
    }

    update() {
        if(Game.freezeTimer > 0) return;

        const p = Game.player;
        const angle = Math.atan2(p.y - this.y, p.x - this.x);
        this.x += Math.cos(angle) * this.speed;
        this.y += Math.sin(angle) * this.speed;

        // Separation
        Game.enemies.forEach(e => {
            if (e === this) return;
            const d = dist(this.x, this.y, e.x, e.y);
            if (d < this.size * 2) {
                const pushAngle = Math.atan2(this.y - e.y, this.x - e.x);
                this.x += Math.cos(pushAngle) * 0.8;
                this.y += Math.sin(pushAngle) * 0.8;
            }
        });
    }

    takeDamage(amt) {
        this.hp -= amt;
        Game.damageNumbers.push(new DamageNumber(this.x, this.y, Math.round(amt)));
        this.flash = 2;
        if (this.hp <= 0) {
            Game.gems.push(new Gem(this.x, this.y));
            for(let i=0; i<4; i++) Game.particles.push(new Particle(this.x, this.y, '#e63946'));
            return true;
        }
        return false;
    }

    draw() {
        CTX.save();
        CTX.translate(this.x, this.y);
        
        // Flash Effect
        CTX.fillStyle = this.flash > 0 ? '#fff' : '#e63946';
        if (this.flash > 0) this.flash--;

        // Draw Swarmer (Rotated Square)
        CTX.rotate(Game.frames * 0.05);
        CTX.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        
        // Inner Core
        CTX.fillStyle = '#1a1b1e';
        CTX.fillRect(-4, -4, 8, 8);
        
        CTX.restore();

        // Health Bar (Floating above)
        if (this.hp < this.maxHp) {
            const hpPct = this.hp / this.maxHp;
            CTX.fillStyle = '#333';
            CTX.fillRect(this.x - 12, this.y - 25, 24, 4);
            CTX.fillStyle = '#e63946';
            CTX.fillRect(this.x - 12, this.y - 25, 24 * hpPct, 4);
        }
    }
}

class Gem {
    constructor(x, y) { this.x = x; this.y = y; this.magnet = false; }
    update() {
        const p = Game.player;
        const d = dist(this.x, this.y, p.x, p.y);
        const pickupRange = 120 * (1 - (Game.entropy/100)) + 40; 
        if (d < pickupRange) this.magnet = true;
        if (this.magnet) {
            const angle = Math.atan2(p.y - this.y, p.x - this.x);
            this.x += Math.cos(angle) * 14;
            this.y += Math.sin(angle) * 14;
        }
    }
    draw() {
        CTX.fillStyle = '#ffaa00'; // Amber XP
        CTX.beginPath();
        CTX.moveTo(this.x, this.y - 5);
        CTX.lineTo(this.x + 5, this.y);
        CTX.lineTo(this.x, this.y + 5);
        CTX.lineTo(this.x - 5, this.y);
        CTX.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = rand(-4, 4); this.vy = rand(-4, 4);
        this.life = 20; this.color = color;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw() {
        CTX.globalAlpha = this.life / 20;
        CTX.fillStyle = this.color;
        CTX.fillRect(this.x, this.y, 4, 4);
        CTX.globalAlpha = 1;
    }
}

class DamageNumber {
    constructor(x, y, val) { this.x = x; this.y = y; this.val = val; this.life = 30; }
    update() { this.y -= 1.5; this.life--; }
    draw() {
        CTX.fillStyle = `rgba(255, 255, 255, ${this.life/30})`;
        CTX.font = "bold 16px 'Roboto Mono'";
        CTX.fillText(this.val, this.x, this.y);
    }
}

function createNova(x, y, range, damage) {
    const pulse = { 
        x, y, range, current: 0, 
        update: function() { this.current += 15; return this.current < this.range; },
        draw: function() {
            CTX.strokeStyle = `rgba(255, 170, 0, ${1 - (this.current/this.range)})`;
            CTX.lineWidth = 4;
            CTX.beginPath();
            CTX.arc(this.x, this.y, this.current, 0, Math.PI*2);
            CTX.stroke();
        }
    };
    Game.particles.push(pulse);
    Game.enemies.forEach(e => {
        if (dist(x, y, e.x, e.y) < range) e.takeDamage(damage);
    });
    Game.shake += 5;
}

// --- GAME LOGIC ---

function startGame() {
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('ui-layer').style.display = 'block';
    init();
}

function init() {
    Game.player = new Player();
    Game.enemies = [];
    Game.projectiles = [];
    Game.gems = [];
    Game.particles = [];
    Game.damageNumbers = [];
    Game.entropy = 0;
    Game.score = 0;
    Game.state = 'RUNNING';
    Game.frames = 0;
    Game.freezeTimer = 0;
    
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('upgrade-screen').style.display = 'none';
    
    loop();
}

function updateCamera() {
    // Camera follows player but stays within world bounds
    Game.camera.x = Game.player.x - Game.width / 2;
    Game.camera.y = Game.player.y - Game.height / 2;
    
    // Clamp camera
    Game.camera.x = Math.max(0, Math.min(Game.camera.x, Game.worldWidth - Game.width));
    Game.camera.y = Math.max(0, Math.min(Game.camera.y, Game.worldHeight - Game.height));
}

function spawnEnemies() {
    if (Game.freezeTimer > 0) return;
    if (Game.frames % 50 === 0) { // Faster spawn than before
        const count = 1 + Math.floor(Game.frames / 500);
        for(let i=0; i<count; i++) Game.enemies.push(new Enemy());
    }
}

function checkCollisions() {
    const p = Game.player;
    const integrity = Math.max(0, 1 - (Game.entropy / 100));

    // Projectile vs Enemy
    for (let i = Game.projectiles.length - 1; i >= 0; i--) {
        const proj = Game.projectiles[i];
        let hit = false;
        for (let e of Game.enemies) {
            if (dist(proj.x, proj.y, e.x, e.y) < e.size + 10) {
                if (e.takeDamage(proj.damage)) {
                    Game.enemies.splice(Game.enemies.indexOf(e), 1);
                }
                hit = true; break;
            }
        }
        if (hit || proj.life <= 0) Game.projectiles.splice(i, 1);
    }

    // Orbital vs Enemy
    const orbitRadius = p.weapons.orbital.radius * (0.5 + 0.5 * integrity);
    for (let i = 0; i < p.weapons.orbital.count; i++) {
        const theta = p.weapons.orbital.angle + (Math.PI * 2 / p.weapons.orbital.count) * i;
        const ox = p.x + Math.cos(theta) * orbitRadius;
        const oy = p.y + Math.sin(theta) * orbitRadius;
        for (let e of Game.enemies) {
            if (dist(ox, oy, e.x, e.y) < e.size + 10) {
                if(Game.frames % 10 === 0) {
                    if(e.takeDamage(p.weapons.orbital.damage * integrity)) {
                        Game.enemies.splice(Game.enemies.indexOf(e), 1);
                    }
                }
            }
        }
    }

    // Gems
    for (let i = Game.gems.length - 1; i >= 0; i--) {
        const g = Game.gems[i];
        if (dist(g.x, g.y, p.x, p.y) < p.baseSize + 10) {
            p.xp++;
            Game.gems.splice(i, 1);
            if (p.xp >= p.nextLevel) levelUp();
        }
    }

    // Enemy vs Player
    for (let e of Game.enemies) {
        if (dist(e.x, e.y, p.x, p.y) < p.baseSize + e.size - 5) {
            Game.entropy += 5; 
            Game.shake += 8;
            e.x -= (e.x - p.x) * 3; // Harder pushback
            e.y -= (e.y - p.y) * 3;
            p.x += (p.x - e.x) * 0.5;
        }
    }
}

function updateUI() {
    // Time format
    const secs = Math.floor(Game.frames / 60);
    const m = Math.floor(secs/60).toString().padStart(2, '0');
    const s = (secs%60).toString().padStart(2, '0');
    document.getElementById('score-display').innerText = `${m}:${s}`;
    
    document.getElementById('level-display').innerText = Game.player.level;
    
    const integrityPct = Math.round((1 - Game.entropy/100) * 100);
    const bar = document.getElementById('entropy-bar');
    
    bar.style.width = `${Game.entropy}%`;
    document.getElementById('entropy-val').innerText = `${integrityPct}%`;
    
    if (Game.entropy > 70) {
        bar.classList.add('critical');
    } else {
        bar.classList.remove('critical');
    }
}

function getUpgradePool() {
    const roll = Math.random();
    let tier = 'common';
    if(roll > 0.60) tier = 'rare';
    if(roll > 0.90) tier = 'epic';
    if(roll > 0.99) tier = 'legendary';

    const p = Game.player;
    const upgrades = [
        { tier: 'common', title: "VENT HEAT", desc: "Reduce Entropy by 15%", action: () => Game.entropy = Math.max(0, Game.entropy - 15) },
        { tier: 'common', title: "REINFORCE", desc: "Slow entropy rate by 10%", action: () => p.decayResist *= 0.9 },
        { tier: 'rare', title: "FLUSH SYSTEM", desc: "Reduce Entropy by 30%", action: () => Game.entropy = Math.max(0, Game.entropy - 30) },
        { tier: 'rare', title: "CALIBRATE", desc: "Blaster damage +15", action: () => p.weapons.blaster.damage += 15 },
        { tier: 'epic', title: "STASIS", desc: "Freeze enemies for 5s", action: () => Game.freezeTimer = 300 },
        { tier: 'epic', title: "NANITES", desc: "Reduce Entropy by 50%", action: () => Game.entropy = Math.max(0, Game.entropy - 50) },
        { tier: 'epic', title: "EMP", desc: "Destroy all visible enemies", action: () => {
            Game.enemies.forEach(e => { createNova(e.x, e.y, 50, 999); Game.gems.push(new Gem(e.x, e.y)); });
            Game.enemies = []; Game.shake = 20;
        }},
        { tier: 'legendary', title: "FULL REBOOT", desc: "ENTROPY TO 0%", action: () => Game.entropy = 0 }
    ];

    let pool = upgrades.filter(u => u.tier === tier);
    if(pool.length === 0) pool = upgrades.filter(u => u.tier === 'common');
    return pool[Math.floor(Math.random() * pool.length)];
}

function levelUp() {
    Game.state = 'PAUSED';
    Game.player.level++;
    Game.player.nextLevel = Math.floor(Game.player.nextLevel * 1.5);
    Game.player.xp = 0;

    const choices = [getUpgradePool(), getUpgradePool(), getUpgradePool()];
    const container = document.getElementById('cards-container');
    container.innerHTML = '';
    
    choices.forEach(opt => {
        const div = document.createElement('div');
        div.className = `card ${opt.tier}`;
        div.innerHTML = `<h3>${opt.title}</h3><p>${opt.desc}</p>`;
        div.onclick = () => {
            opt.action();
            document.getElementById('upgrade-screen').style.display = 'none';
            Game.state = 'RUNNING';
        };
        container.appendChild(div);
    });

    document.getElementById('upgrade-screen').style.display = 'flex';
}

function drawGrid() {
    CTX.strokeStyle = '#23262b';
    CTX.lineWidth = 1;
    const gridSize = 100;
    
    // Calculate offset based on camera to create scrolling effect
    const offsetX = -Game.camera.x % gridSize;
    const offsetY = -Game.camera.y % gridSize;

    CTX.beginPath();
    for (let x = offsetX; x < Game.width; x += gridSize) {
        CTX.moveTo(x, 0); CTX.lineTo(x, Game.height);
    }
    for (let y = offsetY; y < Game.height; y += gridSize) {
        CTX.moveTo(0, y); CTX.lineTo(Game.width, y);
    }
    CTX.stroke();
    
    // Draw World Borders
    CTX.strokeStyle = '#e63946';
    CTX.lineWidth = 4;
    CTX.strokeRect(-Game.camera.x, -Game.camera.y, Game.worldWidth, Game.worldHeight);
}

function loop() {
    if (Game.state !== 'RUNNING') {
        if (Game.state !== 'MENU') requestAnimationFrame(loop);
        return;
    }
    
    requestAnimationFrame(loop);

    // Update Camera
    updateCamera();

    // CLEAR & BACKGROUND
    CTX.fillStyle = '#1a1b1e';
    CTX.fillRect(0, 0, Game.width, Game.height);
    
    // Screen Shake applied to context
    CTX.save();
    if (Game.shake > 0) {
        CTX.translate(rand(-Game.shake, Game.shake), rand(-Game.shake, Game.shake));
        Game.shake *= 0.9;
        if(Game.shake < 0.5) Game.shake = 0;
    }

    drawGrid(); // Draws grid relative to camera

    // --- WORLD SPACE RENDERING ---
    // We translate everything by -Camera.x/y
    CTX.translate(-Game.camera.x, -Game.camera.y);

    // Freeze Effect
    if(Game.freezeTimer > 0) {
        Game.freezeTimer--;
        CTX.fillStyle = 'rgba(0, 200, 255, 0.05)';
        CTX.fillRect(0, 0, Game.worldWidth, Game.worldHeight);
    }

    // Updates
    Game.player.update();
    Game.projectiles.forEach(p => p.update());
    Game.enemies.forEach(e => e.update());
    Game.gems.forEach(g => g.update());
    
    for(let i=Game.particles.length-1; i>=0; i--) {
        if(Game.particles[i].update) { if(!Game.particles[i].update()) Game.particles.splice(i, 1); }
        else { Game.particles[i].update(); if(Game.particles[i].life <= 0) Game.particles.splice(i, 1); }
    }
    
    Game.damageNumbers.forEach((d, i) => {
        d.update();
        if(d.life <= 0) Game.damageNumbers.splice(i, 1);
    });

    // Spawning & Collisions
    spawnEnemies();
    checkCollisions();

    // Draws
    Game.projectiles.forEach(p => p.draw());
    Game.gems.forEach(g => g.draw());
    Game.enemies.forEach(e => e.draw());
    Game.player.draw();
    Game.particles.forEach(p => p.draw());
    Game.damageNumbers.forEach(d => d.draw());

    // Restore context for HUD (so HUD doesn't shake or move)
    CTX.restore();
    
    // --- SCREEN SPACE RENDERING (UI) ---
    updateUI();

    // Check Loss
    if (Game.entropy >= 100) {
        Game.state = 'OVER';
        document.getElementById('final-stats').innerText = `DURATION: ${Math.floor(Game.frames/60)}s`;
        document.getElementById('game-over').style.display = 'flex';
    }

    Game.frames++;
    Game.score++;
}

</script>
</body>
</html>